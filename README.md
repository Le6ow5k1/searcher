##Тестовое задание в Абак

###Задача
В памяти есть 10 000 000 объектов со следующими полями:
 
1. возраст (0..100) 
2. зарплата (0..1000000,0) 
3. рост (0..200) 
4. вес (0..200) 

Нужно написать максимально быстрый алгоритм для выбора объектов по определнным условиям (условий может **быть от 0 до 4**, в качестве условия можно указать **диапазон значений**)

###Решение
Для решения задания было выбранно 3 алгоритма:

- `scan_search` - простое сканирование всего массива объектов с проверкой на соответствие условиям поика
- `selectivity_search` - смысл алгоритма в том, чтобы с каждым проходом по искомому массиву максимально сужать область поика. Для этого вычисляется селективность заданных условий и поиск по ним осуществляется в порядке уменьшения их селективности
- `kdtree_search` - алгоритм с применением в качестве структуры данных разновидности BST - К-мерного дерева

###Анализ

#####Benchmarking
Количество объектов: `10 000 000`

Условия поиска: `:age=>80..150, :salary=>20000..1000000.0, :height=>120..190, :weight=>0..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 3.280000  | 0.010000  | 3.290000   |(  3.292689)|
|selectivity_search:|    7.510000 |  0.020000 |  7.530000 |(  7.567611)|
|scan_search:    |      14.760000 |  0.010000 | 14.770000 |( 14.826757)|


Условия поиска: `:age=>69..100, :salary=>20000.0..80000.0, :height=>150..200, :weight=>110..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 0.170000  | 0.000000  | 0.170000   |(  0.165298)|
|selectivity_search:|    6.450000 |  0.030000  | 6.480000 |(  6.508012)|
|scan_search:    |      12.460000 |  0.000000  |12.460000 |( 12.505126)|


Условия поиска: `:age=>89..100, :height=>180..200, :weight=>40..110`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 0.210000  | 0.000000  | 0.210000   |(  0.214251)|
|selectivity_search:|    5.340000 |  0.030000  | 5.370000 |(  5.385407)|
|scan_search:    |       11.380000|   0.000000  |11.380000  |( 11.428225)|


Условия поиска: `:height=>10..20, :weight=>160..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 0.620000  | 0.000000  | 0.620000   |(  0.618176)|
|selectivity_search:|    5.380000 |  0.030000  | 5.410000 |(  5.431209)|
|scan_search:    |      11.510000 |  0.000000  |11.510000 |( 11.555504)|


Условия поиска: `:salary=>80000.0..200000.0`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 4.240000  | 0.020000  | 4.260000   |(  4.266946)|
|selectivity_search:|    5.860000 |  0.010000  | 5.870000 |(  5.901603)|
|scan_search:    |      12.000000 |  0.000000  |12.000000 |( 12.047652)|


Из тестов можно увидеть, что все алгоритмы чувствительны к набору условий поиска(`scan_search` в меньшей степени).
Самым быстрым оказывается `kdtree_search` алгоритм, однако его существенным недостатком является,
то что на построение дерева уходит достаточно много времени.
