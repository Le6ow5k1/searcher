##Тестовое задание в Абак

###Задача
В памяти есть 10 000 000 объектов со следующими полями:
 
1. возраст (0..100) 
2. зарплата (0..1000000,0) 
3. рост (0..200) 
4. вес (0..200) 

Нужно написать максимально быстрый алгоритм для выбора объектов по определнным условиям (условий может **быть от 0 до 4**, в качестве условия можно указать **диапазон значений**)

###Решение
Для решения задания было выбранно 3 алгоритма:

- `scan_search` - простое сканирование всего массива объектов с проверкой на соответствие условиям поика
- `selectivity_search` - смысл алгоритма в том, чтобы с каждым проходом по искомому массиву максимально сужать область поика. Для этого вычисляется селективность заданных условий и поиск по ним осуществляется в порядке уменьшения их селективности
- `kdtree_search` - алгоритм с применением в качестве структуры данных разновидности BST - К-мерного дерева

###Анализ

#####Benchmarking
Количество объектов: `10 000 000`

Условия поиска: `:age=>30..100, :salary=>90000..1000000.0, :height=>120..190, :weight=>50..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 9.080000  | 0.370000 |  9.450000 |( 31.624776)|
|selectivity_search:|    10.260000 |  0.020000 | 10.280000| ( 10.324110)|
|scan_search:    |      16.610000  | 0.020000 | 16.630000| ( 16.682068)|


Условия поиска: `:age=>60..100, :salary=>200000..1000000.0, :height=>150..190, :weight=>90..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 1.920000  | 0.040000  | 1.960000 |(  2.003038))|
|selectivity_search:|    7.090000 |  0.010000  | 7.100000 |(  7.130504)|
|scan_search:    |      14.120000  | 0.000000 | 14.120000 |( 14.173832)|


Условия поиска: `:age=>89..100, :height=>180..200, :weight=>40..110`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 0.210000  | 0.000000  | 0.210000   |(  0.214251)|
|selectivity_search:|    5.340000 |  0.030000  | 5.370000 |(  5.385407)|
|scan_search:    |       11.380000|   0.000000  |11.380000  |( 11.428225)|


Условия поиска: `:height=>10..20, :weight=>160..200`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 0.620000  | 0.000000  | 0.620000   |(  0.618176)|
|selectivity_search:|    5.380000 |  0.030000  | 5.410000 |(  5.431209)|
|scan_search:    |      11.510000 |  0.000000  |11.510000 |( 11.555504)|


Условия поиска: `:salary=>80000.0..200000.0`

|                |      user |    system |     total  |      real  |
|:--------------:|:---------:|:---------:|:----------:|:----------:|
|kdtree_search:  | 4.130000  | 0.010000  | 4.140000 |(  4.148297)|
|selectivity_search:|    5.860000 |  0.010000  | 5.870000 |(  5.901603)|
|scan_search:    |      12.000000 |  0.000000  |12.000000 |( 12.047652)|



Из тестов можно увидеть, что все алгоритмы чувствительны к набору условий поиска(`scan_search` в меньшей степени).
Самым быстрым оказывается `kdtree_search` алгоритм, однако и ему приходится тяжко если нужно искать в широких диапазонах значений. Связано это с тем, что в таком случае алгоритму приходится "посетить" больше ветвей дерева.

Алгоритм `selectivity_search` наилучшим образом проявляет себя если в списке условий есть хотя бы одно с хорошей селективностью.
В таком случае отбрасывается наибольшое количество ненужных данных. Скорость данного алгоритма ограниченна, т.к. на первой итерации сканируется все равно весь массив.